//Парсер языка однострочный. Одна строка - один оператор.
//Комментарии только однострочные
//У языка огромная схожесть с языком C#
class ClassName
{
	//Классы условны. В языке нет ООП вообще. В языке даже структур нет!
	//Но если очень хочется можно написать свою C#-библиотеку и подключить её
	//Значение константы хранится в дереве.
	const int maxprice = 300;
	//Значение переменной хранится в сохранении. При доступе к переменной вне контекста игры, она вернёт своё значение по умолчанию.
	//переменные должны всегда быть сериализумого типа
	//в качестве значения может использоваться вызов любых значений, для которых не нужен контекст игры
	//в том числе вызов метода в том случае если для него не нужен контекст игры.
	var int price = 200;
	
	//Метод. Ключевое отличие от старого языка квестов. Строгости в обязательности возвращения значений нет.
	//Возвращаемый тип может быть любой абсолютно. Внутренне void это object, имейте это ввиду.
	void Method()
	{
		//Объявление переменной
		//Точка с запятой в конце оператора не обязательна
		var x = 0;
		//Также переменная объявляется при присваивании, если её не существует:
		xx = 0;
		//Однако не стоит использовать эту возможность без необходимости.
		{
			//Объявленные переменные пропадают после конца области действия их объявления
			//Если они заменили переменную, то она не вернётся назад!
			var x = 0;
			var xx = 0;
		}
		//Теперь обеих этих переменных не существует.
		
		//Присваивание переменных:
		x = 1;
		//Расширенное присваивание:
		x += 1;
		x -= 1;
		x *= 1;
		x /= 1;
		x %= 1;
		x |= 1;
		x &= 1;
		x ^= 1;
		//Операций инкремента и декремента нет. Используйте += для ++x. 
		//Все операции являются утверждениеями, а значит их можно писать просто так:
		1 + 2;
		//Каждая операция имеет свой приоритет (даже - над +). Имейте это ввиду.
		//Порядок приоритета по возрастанию:
		//"=", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=", "&&", "||", "&", "|", "^",
		//"is", "==", "!=", ">", ">=", "<", "<=", ">>", "<<", "+", "-", "*", "/", "%", "!", "~"
		//Операции составляются из отдельных символов, так что a + = 1 страктуется как a += 1!
		//Тернарная операция имеет минимальный приоритет
		
		//Выражения имеют возвращаемый тип. Требуемы возвращаемый тип зависит от конструкции.
		#Debug.Log(1); //Возвращаемый тип выражения при вызове равен возвращаемому типу метода (void = object)
		var a1 = x + x; //Возвращаемый тип математического выражения равен наибольшему типу. x is int, x + x is int.
		var b1 = 0.1D + a1; //0.1D is double, a is int => 0.1d + a is double.
		var c1 = (long)x; //Возвращаемый тип приведения всегда равен типу приведения. Используйте это для уточнения при вызове методов.
		
		if (a1 is int) //Сопоставление используется исключительно для проверки типа.
		{
			var b = a1 is int a; //Возможно объявление переменной при сопоставлении.
			#Debug.Log(a is int);
		}
		
		//Старайтесь не переопределять существующие в контексте переменные. Если вы измените глубину их объявления, вы можете запутать самих себя.
		
		//Операторы:
		//Блок:
		{
		}
		//Цикл while:
		while (false)
		{
		}
		//Или краткая версия:
		while (false) null;
		
		//Цикл do-while:
		do
		{
		}
		while (false)
		//Краткой версии не существует
		
		//Цикл loop:
		loop (1)
		{
		}
		//Краткая версия:
		loop (1) null;
		
		//Цикл for:
		//for ([<Statement>]; [<Expression>]; [<Statement>]) [<Statement>];
		for (var i = 0; i < 1; i += 1)
		{
			continue;
			break;
			for (;;) null;
		}
		
		//Условный оператор (краткие версии):
		if (true) Log.Add(1);
		//else if отдельная конструкция
		else if (true) Log.Add(2);
		else Log.Add(0);
		
		//Несколько операторов на одной строке:
		var a = 0; var b = 0;
		//Доступны во всех операторах (но недоступны как возвращающее значение краткого метода)
		while(a + b < 4) a += 1; b += 1;
		
		//Интерполированные строки:
		string s = "{a} {b}"; #Debug.Log(s);
		
		//Имена типа возвращают экземпляр System.Type
		var t = string;
		
		//Обращаться к .NET-типам можно через ##
		//Массивы и их инициализаторы
		var a = new ##System.Type[1] (string);
		
		{
			//Использование .NET-типов:
			#Type.Load(#Type.ConsoleColor);
			//или:         (первое будет быстрее)
			#Type.Load(##System.ConsoleColor);
			#Debug.Log(#ConsoleColor.Black);
			//#Type хранит полные имена типов в значених константы с которотким именем
			//Ознакомьтесь со списком встроенных в Biker Quest Script методов
			
			//Типы существуют до конца области действия, как и переменные.
		}
		
		//Чтобы можно было загружать типы из других сборок, необходимо загрузить эту .NET-сборку
		#BQS.LoadAssembly("KTXCore.dll");
	}
	
	//Короткая запись метода:
	//<TypeName> <FuncName>() => <Expression>;
	//void <FuncName>() => <Statement>;
	int func_() => 1;
}


quest QuestName
{
	title = "Title {(1+1)}";
	
	//access - Text(string key);
	text //словарь нужен для возможного переопределения текста в модах и локализаций
	{
		"desc1" = "Описание квеста в дневнике"
		"desc2" = "Описание квеста появляющееся если выполнено условие"
	}
	
	description
	{
		add "desc1"
		add "desc2" if (true) 
	}
	
	//Возвращает true если в этом контексте можно начать печать квеста
	//ui[<Place>] вернёт true только в случае совпадения с именем места. При любом другом значении вернёт false
	//Удобно делать условия вроде a == 0 ? ui["All"] : ui["PlayerViewer"]
	bool #UIStart(object ui) => ui["All"];
	
	//Специальный метод. Вызывается при #Stage.NS (в состоянии неначатости квеста).
	//Возвращает, можно ли начать выполнение квеста
	bool #Available()
	{
		return true;
	}
	
	//Специальный метод. Вызывается при первом запуске квеста если #Available вернуло true.
	void #Start()
	{
		$Stage = 1;
	}
	
	stage[1]
	{
		//Special methods not access in 
		bool #UIStart(object ui) => ui["All"];
		
		//Planned sugar:
		//uistart => "All" || "All";
		//to : bool #UIStart(object sugar<ui>) => sugar<ui>["All"] || sugar<ui>["All"];
		
		bool #Available() => true;
	
		description
		{
			add "Текст этой стадии"
			add "Текст этой стадии при выполнении условия" if (true)
		}
		
		variant
		{
			string #GetVariantText() => "Текст этого варианта";
			void #Action() => return;
			bool #Available() => false;
			bool #Visible() => false;
		}
		
		//Сахарная сокращённая запись:
		//variant => <Expression> => <Statement>[ => <Expression>[ => <Expression>]];
		//порядок => #GetVariantText => #Action => #Available => #Visible
		variant => "Текст этого варианта" => null; => false => false;
	}
}